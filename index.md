Welcome to My ePortfolio Page.

William Medrano Gutshall.

Computer Science Major at Southern New Hampshire University.

Professional Self-Assessment:


### Code Review:
     Code review is the use of a person or automation to assist in the finding of errors, bad design, and opportunities for improvement. Software development is done by people and thus is prone to mistakes and bugs. As a programmer writing code, we create an emotional attachment to our work and want to believe that our work is correct. Developers also have an insight into the thought process that went into the design and development which means that things that seem clear to the person who wrote the code won’t necessarily seem clear to someone else. This means that as the developer of the code, we are more likely to overlook errors and design flaws, which is why it is crucial to bring in someone else to review the code. Even if the code has been completely debugged and is 100% functional and meets the requirements, it doesn’t necessarily mean that the code meets quality standards. Developers typically work in groups with each person taking on different portions, and code needs to be able to be modified for future changes or expansions. This means that it is also important that the code be simple for another developer to understand and change if necessary. It is extremely difficult for a developer to make this determination on their own, which is why code review is crucial to group development as well. 
     Some of the techniques used for code review include email thread, pair programming, over-the-shoulder, and tool assisted (Huston, 2019). Email thread is an informal approach where the developer sends the code off to fellow developers to be reviewed when time permits (Huston, 2019). This method is flexible but often leaves the developer with numerous different viewpoints which could make determining the direction difficult. Pair programming is often used when a senior developer is mentoring a junior developer and the two developers work side by side working on the same code and checking each other’s work along the way (Huston, 2019). Although this method is a good learning process for the junior developer, it uses more resources and since both developers are involved in the code, it has some of the same drawback of self-review such as emotional attachment. Over-the-shoulder is a review process where the developer sits with another developer as that person reviews their code (Huston, 2019). This informal approach is a great way to get immediate feedback and gives the developer a chance to interact and discuss things with the reviewer; however, this method often lacks tracking and documentation. Another way to perform review is by using automation, or tool assisted code review. This type of method creates good documentation, doesn’t tie up development resources, and some of these tools even allow the entering of requirement information to be reviewed (Huston, 2019); however, this method leaves out the human factor such as can another developer easily follow the code and the ability to ask the reviewer to clarify or assist with suggestions. Code review should be completed after the developer testing phase. This means that after the section of code is completed, the developer should run unit tests to verify the functionality of the code and eliminate any errors. These tests are typically automated, and they can be written by automated applications or written by the developer through testing resources such as JUnit. After the developer testing is completed, then the code moves into the code review phase. 
	At the start of the code review phase, it is good practice for the developer to make sure the source code is properly annotated before passing it off to another developer. This is important because the commenting and annotations made in the source code will allow the reviewer to better understand the thought process of the developer, follow the code easier, and thus be able to provide better feedback to the developer (SmartBear, 2019). The foundation for a productive review is the implementation of a positive code review culture. It is often difficult to take criticism of work that we have an emotional attachment to, and by using the best practice of maintaining a positive culture, it makes the developer more likely to accept and utilize the information provided in the review. I believe that a good code review doesn’t just include what was done wrong or what the reviewer didn’t like, but it also includes what the developer did right and suggestions for how to correct or improve the recommendations. The positives help put the developer into a more comfortable and less defensive mindset and including suggestions for improvements helps the developer understand the mindset of the reviewer. Another best practice is to use lightweight code reviews. According to SmartBear, lightweight code reviews only consume about 20% of the time of formal reviews and they find just as many bugs (2019). The last set of best practices that I advocate are reviewing fewer than 400 lines of code and not to review for more than 60 minutes at a time. According to SmartBear, the mind can only process a certain amount of information, and after 400 lines of code and 60 minutes, the ability to find defects diminishes, and these limitations will be the most efficient because they should yield between 70% to 90% of defect discovery (2019). The one practice that I haven’t really heard discussed before, but I think is important is to not rely on the code review to fix issues. It may seem like the easiest approach, but a code review is about defect discovery and not about leaving defects for someone else to find a solution for. Before code is put up for review it should be fully functional and properly tested by the developer. 


Code Review of IT145 Zoo Authentication application chosen for enhancement:
[![William Medrano Gutshall Code Review](https://github.com/WilliamMedranoGutshall/BigDawg.github.io/blob/master/CodeReviewSnip.JPG)](https://youtu.be/ptY4YaHSm0g "WilliamMedranoGutshallCodeReview")



### Enhancement One
 	The first enhancement started with the final project from IT 145. In this class I created an authentication system for zoo application. The user was given the opportunity to enter a username and password, and these credentials were matched against a file list. The passwords were stored and compared in MD5, message digest, hash form for more security. The user was limited to three failed logins before the program was exited and if they authenticated correctly, they were given access to a file based on their role. I chose this project because it was one of my early projects and I thought is was a great opportunity to show the evolution of my programming skills and mastering of best practices and the SDLC, software development lifecycle. I was given the message digest hashing algorithm that was used for storing and checking passwords, and at this point in my education, I had very little knowledge of hashing or using algorithms to perform functions. I have since studied the process of hashing and practices using more complex algorithms. 
	I chose to convert this program from Java into Python for my first enhancement. Our computer science education exposed us to a wide variety of related topics, and I have learned multiple languages including Java, Python, C++, HTML5, CSS, SAS, and SQL. I feel as if my eportfolio having a similar application developed in both Java and Python would be a great way to display my versatility. I also believe that Python was a better choice for this application since the end goal is to lead into creating a database based application that will allow credentials to be maintained externally to the program code and thus making it more usable for an end user.  This program also allowed me to display my improved code architecture skills and utilize software development best practices for a better designed application. Two of the weak points of my first application were that it was difficult to follow because it wasn’t broken down into separate methods and I had way too many variables. My enhancement removed variables by using lists instead of names such as zooKeeperOne, zooKeeperTwo, and zooKeeperThree. This is a smart design choice because not only does it reduce variables, it makes it much simpler to add additional users. Additions only require adding the username, password, and job title to the correct list and adding one to the number of staff variable. This is all located at the top of the program and clearly indicated by comments. The hashing that was performed by additional code provided in my previous project is performed utilizing a hashing library. The ability to replace an entire algorithm with an import command and library call drastically decreases the amount of code and makes it much simpler to work with. Instead of just displaying a print line depending on the job title, I customized a menu page. Each type of job has its own menu that is called based on the value of the job title list, and the username is passed into the method to be used for personalization. Currently this menu only allows the user to display their job tasks or log out; however, I have created a good foundation to make this feature easy to expand on. I also created some additional job titles to make the application more realistic to an application that would be used. This enhancement completed everything that it was supposed to accomplish and added additional features that wasn’t in the original Java application. I have also begun to work on the second enhancement by adding some input limitations, such as limiting the length of a username to ten characters. If a job title is not recognized in the if/elif loops that call the appropriate menu, then there is a default else statement to warn the user to contact their administrator because they system couldn’t resolve their current position. These limitations as well as adding error handling will be important for hardening my application for good application level security. The hashing algorithm used to store the passwords provides an extra layer of defense because it is harder to steal than it would be if it was just in plain text. I will continue to expand on this in my next enhancement. My design plan for the first and second enhancements hasn’t changed; however, I will be changing my plan for the third enhancement. I ran into issues trying to implement a database using the Eclipse IDE, therefore I will be switching to using Python scripts in Codio to implement and utilize the no-SQL database MongoDB. This change has already been approved. 
	The biggest challenge I faced was working with the MD5 hashing. When I did the original project, I was provided this hashing algorithm and just had to use what I was given. Since I was re-writing this application in Python, I had to figure out how to implement it without it being given to me. As I did some research, I realized that Python has a hashing library available to use. I wasn’t familiar with using it, so I created a Python script in Codio to import the library, convert a given string, and display the output. To verify that it was functioning correctly, I created a test program in Python, copied the output into the program as a variable and used the program to test if the values were the same. This program wouldn’t initially run and was returning a “Non-ASCII character” error. I learned that there are different ways to digest and display the hashing output and to make it functional for my program I had to use the hexdigest() function. I experimented with different ways to implement and use the hexdigest output and ended up saving the output of the hexdigest to a variable and then comparing it to stored value which worked. This was the first time that I truly got some hands-on experience with hashing and I learned more about it working on this application than I have in my previous classes. 
	I also got some good practice working with Python methods. When I look back on my original program, my code was hard to follow and had a lot of variables that weren’t necessary. One of my goals of this enhancement was to write an application that was easy to follow, easy to maintain and easy to expand. My previous Python projects were also lacking good use of methods to complete repeatable functions. For this application I used a separate method for each function, such as checking usernames, checking passwords, and staff menus that were dependent on their job title. I got practice sending and receiving information from these methods, including receiving more than one variable back from the method which I had never done before. I learned some new techniques for working with methods and got practice using good design methodology to create a better version of my previous work. 






```

For more details see [GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/).


