## **Sprint Two: Algorithms and data structures**
### **Expand funcationality & application hardening with error handling and input validation**

### Enhancements
The second enhancement started off with the program from enhancement one. Enhancement one was to convert the final project from IT 145 into Python, which was an authentication system for zoo application. The user was given the opportunity to enter a username and password, and these credentials were matched against a file list. The passwords were stored and compared in MD5, message digest, hash form for more security. The user was limited to three failed logins before the program was exited, and if they authenticated correctly, they were given access to a file based on their role. I chose this project because it was one of my early projects and I thought is was a great opportunity to show the evolution of my programming skills and mastering of best practices and the SDLC, software development lifecycle, and cybersecurity methodology. When I was reviewing my previous projects, this one stood out to me as needing a lot of enhancement to be a viable application. I have since become proficient at using methods to divide up functionality and using lists to minimize numerous related variables. I have also studied cybersecurity and understand the need for application hardening to mitigate attacks. I was honestly stunned that the original application was my project because it was hard to follow and was incredibly vulnerable to attack, and I felt as this was an opportunity to go back and make it right. It also gave me an opportunity to put cybersecurity and testing practices into play because I could look at the program from the view of someone trying to break the code and prevent it. 

Enhancement two was about application hardening security by putting in limitations and error handling. The first thing that I wanted to tackle was the inputs because of buffer overflow attacks. Buffer overflow is a security exploit where an input or process tries to write in more data to a buffer, or block of memory, than it is designed to handle, and it overwrites the adjacent memory (TestOut, 2019). This can cause unwanted actions, application failure, or even allowing an attacker to gain unauthorized access over a system (TestOut, 2019). The inputs for the authentication were the username and the user password. I used a while loop to force the input to be reentered if the value of username exceeded ten characters, and a compound while loop to force another entry if the user password was less than four characters or more than ten. I created the compound requirements for the password for minimum password security. A four-character alphanumeric password is on the short side; however, it would still take more computing power and time than an average hacker would be willing to take to brute force attack the password. Since the time to brute force attack increases exponentially as the number of characters increases, I felt as if anything less than four characters would be too insecure to be used. A zoo that would be using the application can implement tighter security measures and this minimum value can be easily changed. The other security weaknesses that I found with the program involved the lack of error handling. The biggest concern with improper error handling is an application fails into an open state, which means that an attacker can use the access granted by the application to perform unauthorized tasks. Improper error handling can also cause a loss of availability attack if an attacker uses the vulnerability to crash the application and shut down the system (TestOut, 2019). I went throughout the program and contained all my menu options and methods inside try/except commands. The try command runs the block of code nested inside and if it doesn’t successfully complete, the program will fail into the except block. Within the except block was a print statement that provided the user with quick feedback as to why the program failed, such as an error occurred during menu selection. This feedback could be provided from the end user to the developers if a problem persists and guide the developer in locating the issue. There were a couple sections in my original program that used numerous if statements nested within a while loop that could have potentially caused an infinite loop or caused the application to fail. As with the lack of error handling having the potential to fail open, this is a security concern as well as a functional one if the program were to go into an infinite loop. I changed these up to use a combination of if/elif/else statements so that there was always a default selection. This way the program would continue to function properly, and the user can easily recover it. This was unrelated to security, but I decided that original program had too limited of a scope of different types of employees, so I added a couple additional methods with new job types and added a couple test employees to the list. 

### Reflection on Work Completed
I met all the enhancement requirements that I set out to complete for this milestone. I didn’t run into any major issues completing this enhancement; however, I did face some small challenges. This first one is proper indenting. Since the indenting on Python matters to the functionality of the code, when I added try/except lines to each of the methods and had to shift all of the code over, I had to pay close attention to the indenting and make sure it was correct. When I was testing the length of the input to make sure it was within the parameters, I couldn’t get the count feature to work. I researched it and couldn’t find any suggestions on why I was getting my errors. When I reviewed my Python class notes, I found a spreadsheet that I had made with all the commands. As I looked through them, I realized that Python used the len command instead of the count for what I was trying to do and changing the while parameter to use len instead of count fixed that issue. It didn’t take me long to figure out, but I did run into an issue when I attempted to test my two new employees that had the two new job titles. The program had a bug that prevented it from selecting the correct job type and thus call the correct job method because I forgot to change the number of employees in the variable. It took me less than 15 minutes to figure this out and correct the code to fix this bug, because I had the program well commented and the comments brought this to my attention. This project was a great opportunity to implement security practices that I learned in cybersecurity class by going through the application and trying to come up with anyway that a potential attacker can break my program. Putting myself in the point of view of the attacker and trying to determine what I would attack was a productive way to also practice quality control because a tester has the job of trying to determine how to break the code. It gave me a chance to learn to work with try/except commands, something that I previously had little experience in. This project was a great way for me to prove that I could not only recite cyber security practices, but I understand them enought to put them into practice to harden an application. Almost all companies store some type of sensitive data and need all of their developers to be security conscious.  

References
TestOut. (2019). TestOut Security Pro. Retrieved from https://www.testout.com/

### Refactoring Based on Professional Review
As a developer we create an emotional attachment to our work and can often overlook other design choices that would be more efficient or easier to work with. This is why a good developer uses professional code reviews of their work to evaluate and make changes to improve it. A professional review of my work returned the following suggestions and a question: 
- The Style Guide for Python code states that the first line of a function’s block should be a docstring that briefly explains the function’s purpose. This wasn’t a concept I was familiar with, so I researched the Style Guide for Python and docstrings. Docstrings are different from other comments in that they are used to briefly describe what the method or function does and not how it accomplishes it. They are done on the first line of the function, start with a capital letter, end with a period, and are enclosed within “””triple double quotes”””. Unlike comments, docstrings can also be accessed and used such as printing it out. After gaining a better understanding of them and why to use them, I went through my application and on the first line of each method, I added a docstring to explain the purpose of the code.
- Instead of using three lists to individually store the usernames, hashed passwords, and job titles, a single dictionary should be used. This suggestion falls under refactoring, which is restructuring the code without changing the external behavior. Refactoring can often be time consuming and a lot of work, so it must be evaluated to decide if it is worth the resources. Leaving a design choice in place that causes more work to maintain creates a debt. Each time it makes performing maintenance more difficult, interest is paid on that debt. At a given point in time, if the debt is larger than the initial investment required to refactor, then refactoring is a smart choice. On this application, I already experienced about fifteen minutes of debt in the time that it took me to realize I forgot to change the number of employees when I added two more. I also lost about five minutes when I mistakenly mixed up the hashed passwords between two employees. I believe this is a clear indication that if this application was being deployed and used by non-technical employees, the debt would quickly out-weigh the initial investment of refactoring. I eliminated the three lists and all associated variables as well as the two methods that verified passwords and usernames and replaced it with a dictionary declaration and a method that hashes the password being entered. Instead of going to the method to verify the username is in the list by iterating the entire list, a simple if statement was able to be used to verify the username is valid. If it is valid, then the hashed password and job title are returned. The hashing algorithm converts the value of the password being input into the hashed value, which is compared to the value returned from the dictionary. If they match, then the appropriate menu is selected based on their job type. Although it created extra work to refactor the application, I think it was a smart design choice and worth the effort. It demonstrates my ability to make refactoring decisions as well as my acceptance of constructive feedback to make changes to improve my work.
- The original version of the application allowed the user to enter a password even if the username was incorrect and the professional reviewer believed that I should verify the username first. It can be frustrating to users to get the message that the username and passwords don’t match, and they would like to get feedback as to whether it was the username or password that was entered incorrectly. This was a simple change to make so it was well worth the resources to improve the user experience. I nested the password collection and menu selection inside an if/else statement that verified the username first and changed up the print statements. If the user enters the wrong username, then it immediately notifies them the username was incorrect, gives them a count as to how many incorrect entries they have left and returns them to the login menu. Once a proper username is verified, if proceeds to collect the password and verify it. If this process failed, the user was notified that the password was incorrect, given the count and returned to the login menu. As a developer, it is important to consider the experience of the end user and if making a small change improves the user experience without sacrificing security, then as a developer we should make these changes. 
- In my initial application, all the hashed passwords were the same, and the question was asked if I as the developer was aware of this. I was in fact aware that they were all the same because I was using the hashed value of “abcd” for authentication to speed up the operational testing. I used a password that included upper- and lower-case letters as well as numbers and special characters for testing, but I didn’t leave this value in the code after it was tested. This question made me consider that doing this would make my application appear as if it wasn’t fully tested. As a developer that prides himself on performing quality work that is fully tested, I don’t want to ever be in the situation where someone may be wondering how well tested my work is. I went back and created unique passwords with all four-character types using my Python hashing script that I created for this application. This question points out that it is not only important to create good quality code, but it is important for the user to have the perception that it is such so they are confident in using it. 

### User Stories
-  As a zoo administrator, I need to add two more user types: human resource administrator and labor. 
- As a network security administrator, I need the username passwords to be limited to ten characters to help mitigate buffer overflow attacks.
- As a network security administrator, I need the passwords to be a minimum of four characters because anything less will be too easy to brute force attack, and I need the maximum to be ten characters to help mitigate buffer overflow attacks.
- As a network security administrator, I need all loops to include a default value to handle conditions that aren’t defined, such as improperly entered data. 
- As a network security administrator, I need all methods to use proper error handling to prevent the application from failing in the open condition. 

### **Instructions for testing application:**

- Click here to download [Python File](https://williammedranogutshall.github.io/BigDawg.github.io/ZooAuthenticationSecurity.py) for sprint two.

- This application may be imported into an Python compatable IDE or ran as a script. 

- There are five sample user names that can be viewed below the author comments and all three have an unhashed password of "abcd". If additional users are to be added, passwords must be in the hexadecimal form of a MD5 hash to work with the application.

### **Video Demonstration of Code**

[![William Medrano Gutshall Code Review](https://williammedranogutshall.github.io/BigDawg.github.io/ZooAuthenticationSecurity.JPG)](https://youtu.be/e_5a5RgFy_Y "WilliamMedranoGutshallSprintTwo")

### **Instructions for Refactored Version:**

- Click here to download [Python File](https://williammedranogutshall.github.io/BigDawg.github.io/ZooAuthenticationSecurityV2.py) for sprint two.

- This application may be imported into an Python compatable IDE or ran as a script. 

- There are five sample user with the following user names and passwords: Will W1ll, Michelle M1che!!e, Briana Br1@n@, Celina Ce!1n@, and Mike M!k3. If additional users are to be added, passwords must be in the hexadecimal form of a MD5 hash to work with the application.

### **Video Demonstration of Refactoring**

[![William Medrano Gutshall Code Review](https://williammedranogutshall.github.io/BigDawg.github.io/ZooAuthenticationSecurityV2.JPG)](https://youtu.be/Ypf1i8jTOcw "WilliamMedranoGutshallSprintTwo")
